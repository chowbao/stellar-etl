package transform

import (
	"fmt"

	"github.com/stellar/go-stellar-sdk/amount"
	"github.com/stellar/go-stellar-sdk/ingest"
	"github.com/stellar/go-stellar-sdk/support/errors"
	"github.com/stellar/go-stellar-sdk/xdr"
)

func setClaimableBalanceFlagDetails(details map[string]interface{}, flags xdr.ClaimableBalanceFlags) {
	if flags.IsClawbackEnabled() {
		details["claimable_balance_clawback_enabled_flag"] = true
		return
	}
}

func (e *effectsWrapper) addCreateClaimableBalanceEffects(changes []ingest.Change) error {
	source := e.operation.SourceAccount()
	var cb *xdr.ClaimableBalanceEntry
	for _, change := range changes {
		if change.Type != xdr.LedgerEntryTypeClaimableBalance || change.Post == nil {
			continue
		}
		cb = change.Post.Data.ClaimableBalance
		e.addClaimableBalanceEntryCreatedEffects(source, cb)
		break
	}
	if cb == nil {
		return errors.New("claimable balance entry not found")
	}

	details := map[string]interface{}{
		"amount": amount.String(cb.Amount),
	}
	addAssetDetails(details, cb.Asset, "")
	e.addMuxed(
		source,
		EffectAccountDebited,
		details,
	)

	return nil
}

func (e *effectsWrapper) addClaimableBalanceEntryCreatedEffects(source *xdr.MuxedAccount, cb *xdr.ClaimableBalanceEntry) error {
	id, err := xdr.MarshalHex(cb.BalanceId)
	if err != nil {
		return err
	}
	details := map[string]interface{}{
		"balance_id": id,
		"amount":     amount.String(cb.Amount),
		"asset":      cb.Asset.StringCanonical(),
	}
	setClaimableBalanceFlagDetails(details, cb.Flags())
	e.addMuxed(
		source,
		EffectClaimableBalanceCreated,
		details,
	)
	// EffectClaimableBalanceClaimantCreated can be generated by
	// `create_claimable_balance` operation but also by `liquidity_pool_withdraw`
	// operation causing a revocation.
	// In case of `create_claimable_balance` we use `op.Claimants` to make
	// effects backward compatible. The reason for this is that Stellar-Core
	// changes all `rel_before` predicated to `abs_before` when tx is included
	// in the ledger.
	var claimants []xdr.Claimant
	if op, ok := e.operation.operation.Body.GetCreateClaimableBalanceOp(); ok {
		claimants = op.Claimants
	} else {
		claimants = cb.Claimants
	}
	for _, c := range claimants {
		cv0 := c.MustV0()
		e.addUnmuxed(
			&cv0.Destination,
			EffectClaimableBalanceClaimantCreated,
			map[string]interface{}{
				"balance_id": id,
				"amount":     amount.String(cb.Amount),
				"predicate":  cv0.Predicate,
				"asset":      cb.Asset.StringCanonical(),
			},
		)
	}
	return err
}

func (e *effectsWrapper) addClaimClaimableBalanceEffects(changes []ingest.Change) error {
	op := e.operation.operation.Body.MustClaimClaimableBalanceOp()

	balanceID, err := xdr.MarshalHex(op.BalanceId)
	if err != nil {
		return fmt.Errorf("invalid balanceId in op: %d", e.operation.index)
	}

	var cBalance xdr.ClaimableBalanceEntry
	found := false
	for _, change := range changes {
		if change.Type != xdr.LedgerEntryTypeClaimableBalance {
			continue
		}

		if change.Pre != nil && change.Post == nil {
			cBalance = change.Pre.Data.MustClaimableBalance()
			preBalanceID, err := xdr.MarshalHex(cBalance.BalanceId)
			if err != nil {
				return fmt.Errorf("invalid balanceId in meta changes for op: %d", e.operation.index)
			}

			if preBalanceID == balanceID {
				found = true
				break
			}
		}
	}

	if !found {
		return fmt.Errorf("change not found for balanceId : %s", balanceID)
	}

	details := map[string]interface{}{
		"amount":     amount.String(cBalance.Amount),
		"balance_id": balanceID,
		"asset":      cBalance.Asset.StringCanonical(),
	}
	setClaimableBalanceFlagDetails(details, cBalance.Flags())
	source := e.operation.SourceAccount()
	e.addMuxed(
		source,
		EffectClaimableBalanceClaimed,
		details,
	)

	details = map[string]interface{}{
		"amount": amount.String(cBalance.Amount),
	}
	addAssetDetails(details, cBalance.Asset, "")
	e.addMuxed(
		source,
		EffectAccountCredited,
		details,
	)

	return nil
}

func (e *effectsWrapper) addClawbackEffects() error {
	op := e.operation.operation.Body.MustClawbackOp()
	details := map[string]interface{}{
		"amount": amount.String(op.Amount),
	}
	source := e.operation.SourceAccount()
	addAssetDetails(details, op.Asset, "")

	// The funds will be burned, but even with that, we generated an account credited effect
	e.addMuxed(
		source,
		EffectAccountCredited,
		details,
	)

	e.addMuxed(
		&op.From,
		EffectAccountDebited,
		details,
	)

	return nil
}

func (e *effectsWrapper) addClawbackClaimableBalanceEffects(changes []ingest.Change) error {
	op := e.operation.operation.Body.MustClawbackClaimableBalanceOp()
	balanceId, err := xdr.MarshalHex(op.BalanceId)
	if err != nil {
		return errors.Wrapf(err, "Invalid balanceId in op %d", e.operation.index)
	}
	details := map[string]interface{}{
		"balance_id": balanceId,
	}
	source := e.operation.SourceAccount()
	e.addMuxed(
		source,
		EffectClaimableBalanceClawedBack,
		details,
	)

	// Generate the account credited effect (although the funds will be burned) for the asset issuer
	for _, c := range changes {
		if c.Type == xdr.LedgerEntryTypeClaimableBalance && c.Post == nil && c.Pre != nil {
			cb := c.Pre.Data.ClaimableBalance
			details = map[string]interface{}{"amount": amount.String(cb.Amount)}
			addAssetDetails(details, cb.Asset, "")
			e.addMuxed(
				source,
				EffectAccountCredited,
				details,
			)
			break
		}
	}

	return nil
}
